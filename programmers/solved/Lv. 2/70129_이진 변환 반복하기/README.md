
# [✔️/❌][Lv. 2] [70129. 이진 변환 반복하기](https://school.programmers.co.kr/learn/courses/30/lessons/70129)


문제 설명
-----

0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다.

1. x의 모든 0을 제거합니다.
2. x의 길이를 c라고 하면, x를 "c를 2진법으로 표현한 문자열"로 바꿉니다.

예를 들어, `x = "0111010"`이라면, x에 이진 변환을 가하면 `x = "0111010" -> "1111" -> "100"` 이 됩니다.

0과 1로 이루어진 문자열 s가 매개변수로 주어집니다. s가 "1"이 될 때까지 계속해서 s에 이진 변환을 가했을 때, 이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 return 하도록 solution 함수를 완성해주세요.

---

### 제한사항

* s의 길이는 1 이상 150,000 이하입니다.
* s에는 '1'이 최소 하나 이상 포함되어 있습니다.

---

### 입출력 예

| s | result |
| --- | --- |
| `"110010101001"` | `[3,8]` |
| `"01110"` | `[3,3]` |
| `"1111111"` | `[4,1]` |

---

### 입출력 예 설명

입출력 예 #1

* "110010101001"이 "1"이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.

| 회차 | 이진 변환 이전 | 제거할 0의 개수 | 0 제거 후 길이 | 이진 변환 결과 |
| --- | --- | --- | --- | --- |
| 1 | "110010101001" | 6 | 6 | "110" |
| 2 | "110" | 1 | 2 | "10" |
| 3 | "10" | 1 | 1 | "1" |

* 3번의 이진 변환을 하는 동안 8개의 0을 제거했으므로, `[3,8]`을 return 해야 합니다.

입출력 예 #2

* "01110"이 "1"이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.

| 회차 | 이진 변환 이전 | 제거할 0의 개수 | 0 제거 후 길이 | 이진 변환 결과 |
| --- | --- | --- | --- | --- |
| 1 | "01110" | 2 | 3 | "11" |
| 2 | "11" | 0 | 2 | "10" |
| 3 | "10" | 1 | 1 | "1" |

* 3번의 이진 변환을 하는 동안 3개의 0을 제거했으므로, `[3,3]`을 return 해야 합니다.

입출력 예 #3

* "1111111"이 "1"이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.

| 회차 | 이진 변환 이전 | 제거할 0의 개수 | 0 제거 후 길이 | 이진 변환 결과 |
| --- | --- | --- | --- | --- |
| 1 | "1111111" | 0 | 7 | "111" |
| 2 | "111" | 0 | 3 | "11" |
| 3 | "11" | 0 | 2 | "10" |
| 4 | "10" | 1 | 1 | "1" |

* 4번의 이진 변환을 하는 동안 1개의 0을 제거했으므로, `[4,1]`을 return 해야 합니다.


<details>
  <summary><h2>내 풀이(언어)</h2></summary>
  
  ### 정답 코드

  ```python
  def solution(s):
    result = [0, 0]
    while s != "1":
        for c in s:
            if c == "0":
                result[1] += 1
            else:
                pass
        s = s.replace("0", "")
        s = format(len(s), "b")
        result[0] += 1
    return result
  ```
  **풀이과정**
  
  1. 먼저 반복 조건은 "1"이 아닐 때 종료된다. 해당 문제는 이진수 문자열의 길이를 최소화 하는 것인데 이는 이진수 0 또는 이진수 1 이다. 그 때 문자열의 길이가 없을 수 없으므로 무조건 "1"개의 문자열을 가진다.
  2. 조건에서 "0"을 삭제하고 삭제된 총 "0"의 개수를 세므로 전체 문자열을 순회하며 "0"인 부분이 발견될 때마다 카운트를 1 올린다.
  3. 모든 문자열을 순회하면 "0"인 부분을 모두 지우고 남은 문자열의 길이를 다시 이진수로 바꾼다.
  4. 이진 변환한 횟수 또한 카운트 해야하므로 카운트를 1 올린다.

  * 파이썬의 **str.count()** 함수를 사용하면 코드 내의 반복문 사용을 줄일 수 있다.
  * 이진화 관련해서는 파이썬의 다양한 포맷 지정을 사용하거나, 이진수 변환 함수를 사용할 수 있다. (bin(), format(), f-string)
  ---

  <img width="962" alt="스크린샷 2025-01-02 오후 11 34 58" src="https://github.com/user-attachments/assets/f6d73778-d0a1-4209-a1b8-37d3b78b5b75" />

  ### 풀이에 대한 고찰

  크게 어려운 점은 없었다. 다만 str.count()의 존재유무를 몰랐고 2진수 변환 방법을 몰랐기 때문에 실제로 문제가 나왔다면 해맸을 것 같다. 이런 함수들이나 방법들은 미리 숙지하자.

  > 💡 **str.count()** (https://www.entity.co.kr/entry/43-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%AC%B8%EC%9E%90%EC%97%B4-count-%EB%A9%94%EC%86%8C%EB%93%9C)<br>
  > <br>
  > 지정한 문자열에서 특정 문자 혹은 문자열이 반복되는 횟수를 세는 함수이다. 사용법은 str.count(substring[, start[, end]])이며 str은 지정하고자 하는 문자열, substring은 검색하고자 하는 문자 혹은 문자열, start, end는 검색 시작점과 끝점이다. start와 end는 선택 옵션이며 생략 시 처음부터 끝까지 검색한다.  

  > 💡 **진수 변환 방법**(https://spec.tistory.com/475)<br>
  > <br>
  > 1.기본 내장 함수 사용 (bin(int), oct(int), hex(int)) > 반환되는 문자열은 0b, 0o, 0x 접두사를 포함함<br>
  > 2.format() 사용 > format(int, "(형식지정)") > 형식 지정을 통해 문자열을 변환함 형식지정자는 b(2진수), o(8진수), x(16진수)가 있으며 반환되는 문자열은 접두사를 포함하지 않음 (앞에 #을 붙이면 접두사를 포함 할 수 있음)<br>
  > 3.f-string 사용 > f"{int:(형식지정)} > 형식지정자는 위와 동일하다.<br>
  > 형식지정은 진수변환 방법 외에도 여러가지 문자열 표현 방식에 대해 다양하게 이용가능하다.

  ## 다른 사람 풀이


  ### 코드1
  ```python
  def solution(s):
    a, b = 0, 0
    while s != '1':
        a += 1
        num = s.count('1')
        b += len(s) - num
        s = bin(num)[2:]
    return [a, b]
  ```
  ### 설명
  풀이 방식은 나와 동일하다 다만 다른 점은 str.count()를 사용했다는 것과 코드 효율을 높이기 위해 "1"을 카운트하고 전체 길이에서 해당 카운트를 빼는 것으로 "0"의 개수 또한 알아낼 수 있다는 아이디어에 차이가 있다.

  ### 코드2
  ```python
  def binary(num):
    if num < 2:
        return str(num)
    return binary(num // 2) + str(num % 2)

  def solution(s):
      answer = []

      zero_count = 0
      repeat_count = 0
      while s != '1':
          repeat_count += 1
          prev_s_length = len(s)
          s = s.replace('0', '')
          after_s_length = len(s)
          zero_count += prev_s_length - after_s_length
          c = len(s)
          s = binary(c)

      answer.append(repeat_count)
      answer.append(zero_count)
      return answer
  ```
  ### 설명
  파이썬의 이진수 변환 방법을 이용하지 않고 재귀를 통해 이진수 변환을 진행하는 코드이다. 개인적으로 재귀는 직관적으로 파악하기 힘들어 선호하지 않지만, 재귀를 이런 식으로 활용할 수 있음을 알아두자.

  ### 코드3
  ```python
  def makeBin(len):
      result = []
      while len != 0:
          if len % 2 == 1:
              result.append("1")
              len = (len-1)/2
          else:
              result.append("0")
              len = len/2
      return result

  def solution(s):
      answer = []
      x = s[:]
      zero_count = 0
      itr_count = 0
      if x == "1":
          answer = [0, 0]
      else:
          while x != "1":
              temp = []
              itr_count += 1
              for i in x:
                  if i == "1":
                      temp.append("1")
                  else:
                      zero_count += 1
              x = "".join(makeBin(len(temp)))
      answer = [itr_count, zero_count]
      return answer
  ```
  ### 설명
  위 코드와 방식은 동일하게 이진수 변환 방법을 사용하지 않은 코드이다.  
  다만 다른점은 재귀를 사용하지 않고 반복문을 통해 모든 문자열을 변환한다는 점이다.  
  진법 변환 방법 중 변환 함수나 방법이 기억나지 않는 경우 위와 같이 변환 함수 자체를 구현한다는 방법이 있다는 것을 기억하자.
  
  ### 출처
  [프로그래머스 다른사람 풀이](https://school.programmers.co.kr/learn/courses/30/lessons/70129/solution_groups?language=python3)

  ## 회고
  Lv. 2의 문제임에도 불구하고 정답률이 높은데에는 이유가 있는 것 같다..
  시간 복잡도 같은 제약조건이 없어서 단순 구현으로 쉽게 풀 수 있는 문제였다.  
  다만, 파이썬 함수를 사용하면 더욱 쉽게 풀 수 있었던 문제인 만큼 문제를 풀며 중요한 파이썬 함수는 암기가 필요하다 생각했다.

</details>
<br>
<span style="color:gray"> #월간 코드 챌린지 시즌1 </span>
